{"ts":1354984012340,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"ï»¿\n\nArray.prototype.ContainsPerson = function (value) {\n\n    for (var i = 0; i < this.length; i++) {\n\n        if (this[i].PersonId == value.PersonId) {\n            return true;\n        }\n    }\n\n\n\n    return false;\n\n}\n\n\nArray.prototype.SortByGenIdx = function()\n{\n\tfor(i=0;i<this .length;i++)\n\t{\n\t\tfor(j=i+1;j<this.length;j++)\n\t\t{\n\t\t\tif(Number(this[i].GenerationIdx) < Number(this[j].GenerationIdx))\n\t\t\t{\n\t\t\t\ttempValue = this[j];\n\t\t\t\tthis[j] = this[i];\n\t\t\t\tthis[i] = tempValue;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nfunction AncTree() {\n\n        $.extend(this, new TreeBase());\n\n        this.adjustedDistances = new Array();\n        this.adjustedBoxWidths = new Array();\n        this.adjustedBoxHeights = new Array();\n\n        this.moveList =  new Array();\n\n        this.newX1 =0.0;\n        this.newX2 =0.0;\n\n        this.workingX1 =0.0;\n        this.workingX2 =0.0;\n\n\n        this.DrawTree = function () {\n\n           var canvas = document.getElementById(\"myCanvas\");\n           var context = canvas.getContext(\"2d\");\n           canvas.width = window.innerWidth;\n           canvas.height = window.innerHeight;\n\n\n           this.ComputeLocations();\n\n           var topLeftCornerX = 188;\n           var topLeftCornerY = 50;\n           var width = 200;\n           var height = 100;\n\n\n\n           var _genidx = 0;\n           var _personIdx = 0;\n           //this.generations.length\n\n           var treeUI = new TreeUI(this.screenWidth, this.screenHeight, this.boxWidth, this.boxHeight);\n\n           this.links = new Array();\n\n           while (_genidx < this.generations.length) {\n               _personIdx = 0;\n\n               while (_personIdx < this.generations[_genidx].length) {\n\n                   var _person = this.generations[_genidx][_personIdx];\n\n                   var personLink = treeUI.DrawPerson(_person,this.sourceId, this.zoomPercentage);\n\n                   if(personLink != null)\n                    this.links.push(personLink);\n\n                   _personIdx++;\n               }\n               _genidx++;\n           }\n\n           var _fslOuter = 0;\n           var _fslInner = 0;\n           //   var _pointIdx = 0;\n\n\n           while (_fslOuter < this.familySpanLines.length) {\n               _fslInner = 0;\n               while (_fslInner < this.familySpanLines[_fslOuter].length) {\n                   treeUI.DrawLine(this.familySpanLines[_fslOuter][_fslInner]);\n                   _fslInner++;\n               } // end familySpanLines[_fslOuter].length\n\n               _fslOuter++;\n           } // end this.familySpanLines.length\n\n\n       }\n\n        this.ComputeLocations = function () {\n\n\n\n\n        var genidx = 0;\n        this.drawingX2 = 0.0;\n        this.drawingX1 = 0.0;\n        var _y = this.centreVerticalPoint;\n        var percentageLess = 0.0;\n\n        //            adjustedDistances = new List<double>(generations.Count);\n        //            adjustedBoxWidths = new List<double>(generations.Count);\n        //            adjustedBoxHeights = new List<double>(generations.Count);\n        this.adjustedDistances = new Array();\n        this.adjustedBoxWidths = new Array();\n        this.adjustedBoxHeights = new Array();\n\n\n        this.generations[0][0].X1 = this.centrePoint;\n        this.generations[0][0].X2 = this.centrePoint + this.boxWidth;\n        this.generations[0][0].Y1 = _y;\n        this.generations[0][0].Y2 = _y + this.boxHeight;\n\n        //            var newX1 = 0.0;\n        //            var newX2 = 0.0;\n\n\n        genidx = 0;\n        while (genidx < this.generations.length) {\n\n\n            var personIdx = 0;\n\n            percentageLess += 2;\n\n           // console.log('GENERATION: ' + genidx);\n\n            while (personIdx < this.generations[genidx].length) {\n\n                this.GetNewX(genidx,\n                        percentageLess,\n                        personIdx); // fills newxs\n\n                var overlap = 0.0;\n                var requiredSpace = 0.0;\n                if (personIdx > 0) {\n\n                    if (this.generations[genidx][personIdx - 1].X2 > this.newX1) {\n                        overlap = this.generations[genidx][personIdx - 1].X2 - this.newX1;\n                        overlap += this.adjustedDistances[genidx];\n                    }\n\n                    var newChildidx = this.generations[genidx][personIdx].ChildIdx;\n                    var oldChildidx = this.generations[genidx][personIdx - 1].ChildIdx;\n                    var countPersonSpaces = newChildidx - oldChildidx;\n\n                    if (countPersonSpaces > 1) {\n\n                        countPersonSpaces--;\n                        //needed space\n                        requiredSpace = (countPersonSpaces * this.adjustedBoxWidths[genidx - 1]) + ((countPersonSpaces + 1) * (this.adjustedDistances[genidx - 1] + 5));\n\n                        var spaceSoFarCreated = (this.generations[genidx - 1][newChildidx].X1 - this.generations[genidx - 1][oldChildidx].X2) + overlap;\n\n                        // we dont have enough space!\n                        if (requiredSpace > spaceSoFarCreated) {\n                            // increase the overlap so enough space if provided\n                            overlap += (requiredSpace - spaceSoFarCreated);\n                        }\n                        else if (overlap == 0) {\n                            overlap = (requiredSpace - spaceSoFarCreated);\n                        }\n\n                    }\n\n                }\n\n\n\n\n                if (overlap > 0) {\n\n                   // console.log('overlaped: ' + personIdx);\n\n                    this.getMoveList(personIdx - 1, genidx);\n\n                    this.moveList.SortByGenIdx();\n\n                    //var sorted = moveList.OrderByDescending(o => o.GenerationIdx);\n\n                    var listIdx = 0;\n                    // }\n\n                    //                    $.each(this.moveList, function (index, _treePerson) {\n\n\n                    while (listIdx < this.moveList.length) {\n                        var _treePerson = this.moveList[listIdx];\n                        var tpPersonIdx = _treePerson.Index;\n\n                        while (tpPersonIdx >= 0) {\n\n                            //      Debug.WriteLine(\"moving: \" + this.generations[_treePerson.generation][tpPersonIdx].name);\n                            //console.log(\"moving: \" + _treePerson.Name + \" \" + _treePerson.X1 + \" \" + _treePerson.X2);\n\n                            var _movePerson = this.generations[_treePerson.GenerationIdx][tpPersonIdx];\n\n                            var _prevPerson = null;\n                            var _nextPerson = null;\n\n\n                            if (tpPersonIdx > 0)\n                                _prevPerson = this.generations[_treePerson.GenerationIdx][tpPersonIdx - 1];\n\n                            if ((tpPersonIdx + 1) < this.generations[_treePerson.GenerationIdx].length)\n                                _nextPerson = this.generations[_treePerson.GenerationIdx][tpPersonIdx + 1];\n\n                            this.workingX1 = 0.0;\n                            this.workingX2 = 0.0;\n\n                            if ((_movePerson.FatherIdx == -1 && _movePerson.MotherIdx == -1) || (_movePerson.GenerationIdx == genidx)) {\n                                if (_movePerson.GenerationIdx == genidx) {\n                                    this.workingX1 = _movePerson.X1 - overlap;\n                                    this.workingX2 = _movePerson.X2 - overlap;\n                                }\n                                else {\n\n                                    var parentlessPersonStartX = _movePerson.X1 - overlap; // GetX1ForParentlessPerson(_movePerson.generation, _movePerson.index);\n\n                                    if (parentlessPersonStartX == 0.0) {\n                                        parentlessPersonStartX = 15;\n                                        this.workingX2 = _nextPerson.X1 - parentlessPersonStartX;\n                                        this.workingX1 = this.workingX2 - this.adjustedBoxWidths[_nextPerson.GenerationIdx];\n                                    }\n                                    else {\n                                        this.workingX1 = parentlessPersonStartX;\n                                        this.workingX2 = this.workingX1 + this.adjustedBoxWidths[_nextPerson.GenerationIdx];\n                                    }\n                                }\n\n                            }\n                            else {\n                                this.CreateChildPositionFromParent(_movePerson); //sets workingXs \n                            }\n\n                         //   if (this.workingX1 == -3830.17696197631 && this.workingX2 == -3773.62983468031 && _treePerson.Name == 'James Reeves') {\n                          //      console.log('hello');\n                          //  }\n\n                           // console.log('working 1 and 2: ' + this.workingX1 + ' - ' + this.workingX2);\n\n                            _movePerson.X1 = this.workingX1; // -adjustedDistanceApart;\n                            _movePerson.X2 = this.workingX2; // -adjustedDistanceApart;\n\n                            tpPersonIdx--;\n                        } //end while (tpPersonIdx >= 0)\n\n                        listIdx++;\n                    } // end listIdx < this.moveList.length\n\n\n\n\n                }\n\n                this.generations[genidx][personIdx].X1 = this.newX1; // _x - adjustedBoxWidth;\n                this.generations[genidx][personIdx].X2 = this.newX2; // _x + adjustedBoxWidth;\n\n                this.generations[genidx][personIdx].Y1 = _y;\n                this.generations[genidx][personIdx].Y2 = _y + this.adjustedBoxHeights[genidx];\n\n\n                this.CalcTPZoom(genidx, personIdx);\n\n                personIdx++;\n            }\n\n            _y -= this.distanceBetweenGens;\n\n            genidx++;\n\n        }\n\n\n\n        //, ref newX1, ref newX2\n        this.CreateChildPositionFromParent(this.generations[0][0]); //sets workingXs \n\n        this.generations[0][0].X1 = this.workingX1;\n        this.generations[0][0].X2 = this.workingX2;\n\n        this.generations[0][0].IsDisplayed =true;\n\n        genidx = 0;\n\n        this.drawingX1 = this.generations[0][0].X1;\n        this.drawingX2 = this.generations[0][0].X2;\n\n        while (genidx < this.generations.length) {\n            if (this.drawingX1 > this.generations[genidx][0].X1)\n                this.drawingX1 = this.generations[genidx][0].X1;\n\n            if (this.drawingX2 < this.generations[genidx][this.generations[genidx].length - 1].X2)\n                this.drawingX2 = this.generations[genidx][this.generations[genidx].length - 1].X2;\n\n            genidx++;\n        }\n\n        // top of the screen\n        this.drawingY1 = this.generations[this.generations.length - 1][0].Y2;\n\n        //bottom of the screen\n        this.drawingY2 = this.generations[0][0].Y1;\n\n        this.drawingHeight = this.generations[0][0].Y1 - this.generations[this.generations.length - 1][0].Y2;\n\n        this.drawingCentre = (this.drawingX2 - this.drawingX1) / 2;\n        this.drawingWidth = this.drawingX2 - this.drawingX1;\n\n\n\n\n        this.CreateConnectionLines();\n\n\n    }        //end compute locations\n\n        this.CreateConnectionLines = function () {\n\n        // this.FamilySpanLines = new List<List<List<TreePoint>>>();\n\n        var middleGeneration = 0.0;\n        var middleXChild = 0.0;\n        var middleParent = 0.0;\n        var middleTopChild = 0.0;\n        var bottomParent = 0.0;\n\n        var parentHeight = 0.0;\n        var distanceBetweenGens = 0.0;\n\n\n        var genidx = 0;\n        while (genidx < this.generations.length) {\n\n            var personIdx = 0;\n\n            if (genidx + 1 >= this.familySpanLines.length) {\n                genidx++;\n                continue;\n            }\n\n\n            while (personIdx < this.generations[genidx].length) {\n                var _family0 = this.familySpanLines[genidx][personIdx];\n\n                //_family0[_family0.length] = new Array(_secondStorkX, _firstRow);\n                              \n                _family0 = new Array();\n                //familySpanLines[genidx][personIdx].Clear();\n\n                middleTopChild = this.generations[genidx][personIdx].Y1;// + 10\n                if (this.generations.length > (genidx + 1)) {\n                    parentHeight = (this.generations[genidx + 1][0].Y2 - this.generations[genidx + 1][0].Y1);\n                    bottomParent = this.generations[genidx + 1][0].Y1 + parentHeight;// + 10\n                    distanceBetweenGens = (this.generations[genidx][personIdx].Y1 - this.generations[genidx + 1][0].Y2);\n\n                    if (this.generations[genidx][personIdx].FatherIdx > 0 || this.generations[genidx][personIdx].MotherIdx > 0) {\n                        // top middle of child \n                        middleXChild = (this.generations[genidx][personIdx].X1 + this.generations[genidx][personIdx].X2) / 2;\n                        middleGeneration = this.generations[genidx][personIdx].Y1 - (distanceBetweenGens / 2) + 10;\n                        // move to top and middle of child\n                        // familySpanLines[genidx][personIdx].Add(new TreePoint(middleXChild, middleTopChild));\n                        _family0[_family0.length] = new Array(middleXChild, middleTopChild);\n\n                        // move to middle of generations about child\n                        // familySpanLines[genidx][personIdx].Add(new TreePoint(middleXChild, middleGeneration));\n                        _family0[_family0.length] = new Array(middleXChild, middleGeneration);\n\n                        var patIdx = this.generations[genidx][personIdx].FatherIdx;\n                        if (patIdx != -1) {\n                            // move to middle generation under parent\n                            middleParent = (this.generations[genidx + 1][patIdx].X1 + this.generations[genidx + 1][patIdx].X2) / 2;\n\n\n                            //familySpanLines[genidx][personIdx].Add(new TreePoint(middleParent, middleGeneration));\n                            _family0[_family0.length] = new Array(middleParent, middleGeneration);\n\n                            if (this.drawingHeight > 200) {\n                                // move to bottom of parent\n                                //familySpanLines[genidx][personIdx].Add(new TreePoint(middleParent, bottomParent));\n                                _family0[_family0.length] = new Array(middleParent, bottomParent);\n                            }\n                            else {\n                                //familySpanLines[genidx][personIdx].Add(new TreePoint(middleParent, middleGeneration - 4));\n                                _family0[_family0.length] = new Array(middleParent, middleGeneration - 4);\n                            }\n                            // move to middle generation under parent\n                            //familySpanLines[genidx][personIdx].Add(new TreePoint(middleParent, middleGeneration));\n                            _family0[_family0.length] = new Array(middleParent, middleGeneration);\n                            // move to middle of child\n                            // familySpanLines[genidx][personIdx].Add(new TreePoint(middleXChild, middleGeneration));\n                            _family0[_family0.length] = new Array(middleXChild, middleGeneration);\n                            // move to top and middle of child\n                            // familySpanLines[genidx][personIdx].Add(new TreePoint(middleXChild, middleTopChild));\n                            _family0[_family0.length] = new Array(middleXChild, middleTopChild);\n                        }\n                        patIdx = this.generations[genidx][personIdx].MotherIdx;\n                        if (patIdx != -1) {\n                            middleParent = (this.generations[genidx + 1][patIdx].X1 + this.generations[genidx + 1][patIdx].X2) / 2;\n                            // move to middle of generations about child\n                            // familySpanLines[genidx][personIdx].Add(new TreePoint(middleXChild, middleGeneration));\n                            _family0[_family0.length] = new Array(middleXChild, middleGeneration);\n\n                            //familySpanLines[genidx][personIdx].Add(new TreePoint(middleParent, middleGeneration));\n                            _family0[_family0.length] = new Array(middleParent, middleGeneration);\n\n                            if (this.drawingHeight > 200) {\n                                // move to bottom of parent\n                                //familySpanLines[genidx][personIdx].Add(new TreePoint(middleParent, bottomParent));\n                                _family0[_family0.length] = new Array(middleParent, bottomParent);\n                            }\n                            else {\n                                //familySpanLines[genidx][personIdx].Add(new TreePoint(middleParent, middleGeneration - 4));\n                                _family0[_family0.length] = new Array(middleParent, middleGeneration - 4);\n                            }\n                            // move to middle generation under parent\n                            // familySpanLines[genidx][personIdx].Add(new TreePoint(middleParent, middleGeneration));\n                            _family0[_family0.length] = new Array(middleParent, middleGeneration);\n                            // move to middle of child\n                            // familySpanLines[genidx][personIdx].Add(new TreePoint(middleXChild, middleGeneration));\n                            _family0[_family0.length] = new Array(middleXChild, middleGeneration);\n                            // move to top and middle of child\n\n                            //familySpanLines[genidx][personIdx].Add(new TreePoint(middleXChild, middleTopChild));\n                            _family0[_family0.length] = new Array(middleXChild, middleTopChild);\n                        } //end (patIdx != -1)\n                    } //end  if (this.generations[genidx][personIdx].FatherIdx > 0 || this.generations[genidx][personIdx].MotherIdx > 0)\n                } //if (this.generations.length > (genidx + 1))\n\n\n                this.familySpanLines[genidx][personIdx] = _family0;\n\n                personIdx++;\n            }\n\n            genidx++;\n        }\n\n\n\n    } //this.CreateConnectionLines\n\n        this.CreateChildPositionFromParent = function (movePerson) {\n        \n            this.workingX1 = 0.0;\n            this.workingX2 = 0.0;\n            var boxWidth = 0.0;\n\n            if (this.adjustedBoxWidths.length > movePerson.GenerationIdx)\n            {\n                this.boxWidth = this.adjustedBoxWidths[movePerson.GenerationIdx];\n                }\n            else\n            {\n                this.boxWidth = this.boxWidth;\n                }\n\n            if (movePerson.FatherIdx == -1)\n            {\n                this.workingX1 = ((this.generations[movePerson.GenerationIdx + 1][movePerson.MotherIdx].X1 + this.generations[movePerson.GenerationIdx + 1][movePerson.MotherIdx].X2) / 2) - (this.boxWidth / 2);\n                this.workingX2 = this.workingX1 + this.boxWidth;\n            }\n\n            if (movePerson.MotherIdx == -1)\n            {\n                this.workingX1 = ((this.generations[movePerson.GenerationIdx + 1][movePerson.FatherIdx].X1 + this.generations[movePerson.GenerationIdx + 1][movePerson.FatherIdx].X2) / 2) - (this.boxWidth / 2);\n                this.workingX2 = this.workingX1 + this.boxWidth;\n            }\n\n            var parentX1 = 0.0;\n            var parentX2 = 0.0;\n\n            if (movePerson.FatherIdx != -1 && movePerson.MotherIdx != -1)\n            {\n                parentX2 = this.generations[movePerson.GenerationIdx + 1][movePerson.MotherIdx].X2;\n                parentX1 = this.generations[movePerson.GenerationIdx + 1][movePerson.FatherIdx].X1;\n\n                if (movePerson.FatherIdx > movePerson.MotherIdx)\n                {\n                    parentX2 = this.generations[movePerson.GenerationIdx + 1][movePerson.FatherIdx].X2;\n                    parentX1 = this.generations[movePerson.GenerationIdx + 1][movePerson.MotherIdx].X1;\n                }\n\n                this.workingX1 = ((parentX2 + parentX1) / 2) - ((movePerson.X2 - movePerson.X1) / 2);\n                this.workingX2 = this.workingX1 + (movePerson.X2 - movePerson.X1);\n            }\n        }\n\n        this.GetNewX = function (genidx, percentageLess, personIdx) {\n\n\n            var adjustedBoxHeight = 0.0;\n            var adjustedDistanceApart = 0.0;\n            var adjustedBoxWidth = 0.0;\n\n            var childIdx = this.generations[genidx][personIdx].ChildIdx;\n\n            if (genidx > 0) {\n                adjustedBoxHeight = this.boxHeight - ((this.boxHeight / 100) * percentageLess);\n                var childBoxWidth = (this.generations[genidx - 1][childIdx].X2 - this.generations[genidx - 1][childIdx].X1);\n                var childCentrePoint = this.generations[genidx - 1][childIdx].X1 + (childBoxWidth / 2);\n                adjustedDistanceApart = this.distanceBetweenBoxs - ((this.distanceBetweenBoxs / 100) * percentageLess);\n                adjustedBoxWidth = childBoxWidth - ((childBoxWidth / 100) * percentageLess);\n\n                var isFirstParent = false;\n                var isLastParent = false;\n                var isSingleParent = false;\n\n                //trying to determine which of the parents we are refering to\n                // because if its the first then x value will be lower than it would be for 2nd \n                if (this.generations[genidx].length > personIdx + 1) {\n                    if (this.generations[genidx][personIdx + 1].ChildIdx == this.generations[genidx][personIdx].ChildIdx) {\n                        isFirstParent = true;\n                    }\n\n                }\n\n                if (personIdx > 0) {\n                    if (this.generations[genidx][personIdx].ChildIdx == this.generations[genidx][personIdx - 1].ChildIdx) {\n                        isLastParent = true;\n                    }\n                }\n\n                if (!isFirstParent && !isLastParent) {\n                    isSingleParent = true;\n                }\n                if (isFirstParent) {\n                    this.newX1 = childCentrePoint - (adjustedDistanceApart / 2) - adjustedBoxWidth;\n\n                }\n\n                if (isLastParent) {\n                    this.newX1 = childCentrePoint + (adjustedDistanceApart / 2);\n                }\n\n                if (isSingleParent) {\n                    this.newX1 = childCentrePoint - (adjustedBoxWidth / 2);\n                }\n\n\n                // newX1 = initialCentrePoint - newX1;\n            }\n            else {\n                adjustedBoxHeight = this.boxHeight;\n                adjustedBoxWidth = this.boxWidth;\n                this.newX1 = this.centrePoint;\n            }\n\n\n\n            if (this.adjustedDistances.length > genidx) {\n                this.adjustedDistances[genidx] = adjustedDistanceApart;\n            }\n            else {\n                this.adjustedDistances[this.adjustedDistances.length] = adjustedDistanceApart;\n            }\n\n            if (this.adjustedBoxWidths.length > genidx) {\n                this.adjustedBoxWidths[genidx] = adjustedBoxWidth;\n            }\n            else {\n                //this.adjustedBoxWidths[this.adjustedBoxWidths.length] = adjustedBoxWidth;\n                this.adjustedBoxWidths.push(adjustedBoxWidth);\n            }\n\n\n            if (this.adjustedBoxHeights.length > genidx) {\n                this.adjustedBoxHeights[genidx] = adjustedBoxHeight;\n            }\n            else {\n                //this.adjustedBoxHeights[this.adjustedBoxWidths.length] = adjustedBoxHeight;\n                this.adjustedBoxHeights.push(adjustedBoxHeight);\n            }\n\n\n\n\n            this.newX2 = this.newX1 + adjustedBoxWidth;\n\n\n        } //end getnewx\n\n        this.getMoveList = function (person, startGen) {\n\n            this.moveList = new Array();\n            var moveGenIdx = startGen;\n\n           \n            while (moveGenIdx > 0)\n            {\n\n                if (!this.moveList.ContainsPerson(this.generations[moveGenIdx][person]))\n                {\n                    this.moveList.push(this.generations[moveGenIdx][person]);\n                }\n\n                person = this.generations[moveGenIdx][person].ChildIdx;\n\n                moveGenIdx--;\n            }\n\n\n        } //end  this.getMoveList = function (person, startGen) {\n\n}"]],"start1":0,"start2":0,"length1":0,"length2":24428}]],"length":24428}
{"contributors":[],"silentsave":false,"ts":1354984079759,"patch":[[{"diffs":[[-1,"ï»¿\n\nArray.prototype.ContainsPerson = function (value) {\n\n    for (var i = 0; i < this.length; i++) {\n\n        if (this[i].PersonId == value.PersonId) {\n            return true;\n        }\n    }\n\n\n\n    return false;\n\n}\n\n\nArray.prototype.SortByGenIdx = function()\n{\n\tfor(i=0;i<this .length;i++)\n\t{\n\t\tfor(j=i+1;j<this.length;j++)\n\t\t{\n\t\t\tif(Number(this[i].GenerationIdx) < Number(this[j].GenerationIdx))\n\t\t\t{\n\t\t\t\ttempValue = this[j];\n\t\t\t\tthis[j] = this[i];\n\t\t\t\tthis[i] = tempValue;\n\t\t\t}\n\t\t}\n\t}\n}"],[1,"\n"],[0,"\n\n\nf"]],"start1":0,"start2":0,"length1":493,"length2":5}]],"length":23940,"saved":false}
{"ts":1354984097606,"patch":[[{"diffs":[[1,"var TreeBase;"],[0,"\n\n\n\nfunction"]],"start1":0,"start2":0,"length1":12,"length2":25}]],"length":23953,"saved":false}
